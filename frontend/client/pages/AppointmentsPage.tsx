import React, { useState, useMemo, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import type { Appointment, TreatmentCourse, User, Service, Review } from '../../types';
import { BellIcon, XCircleIcon, StarIcon } from '../../shared/icons';
import * as apiService from '../services/apiService';
import { formatDateDDMMYYYY, parseDDMMYYYYToYYYYMMDD } from '../../shared/dateUtils';


interface AppointmentsPageProps {
    currentUser: User;
    allServices: Service[];
    allUsers: User[];
    allAppointments: Appointment[];
    allTreatmentCourses: TreatmentCourse[];
}

export const AppointmentsPage: React.FC<AppointmentsPageProps> = ({
    currentUser,
    allServices,
    allUsers,
    allAppointments,
    allTreatmentCourses,
}) => {
    const navigate = useNavigate();
    const [localAppointments, setLocalAppointments] = useState<Appointment[]>([]);
    const [localTreatmentCourses, setLocalTreatmentCourses] = useState<TreatmentCourse[]>(allTreatmentCourses);
    const [isLoadingAppointments, setIsLoadingAppointments] = useState(true);
    const [activeTab, setActiveTab] = useState<'upcoming' | 'history' | 'courses'>('upcoming');
    const [viewingAppointment, setViewingAppointment] = useState<(Appointment & { dateTime: Date }) | null>(null);
    const [appointmentToCancel, setAppointmentToCancel] = useState<(Appointment & { dateTime: Date }) | null>(null);
    const [toastMessage, setToastMessage] = useState<string | null>(null);

    // Filter & Sort States
    const [upcomingSort, setUpcomingSort] = useState('date-asc');
    const [upcomingFilterService, setUpcomingFilterService] = useState('all');
    const [upcomingFilterTime, setUpcomingFilterTime] = useState('all');
    const [dateRangeStart, setDateRangeStart] = useState<string>(''); // YYYY-MM-DD format for filtering
    const [dateRangeEnd, setDateRangeEnd] = useState<string>(''); // YYYY-MM-DD format for filtering
    const [dateRangeStartDisplay, setDateRangeStartDisplay] = useState<string>(''); // DD/MM/YYYY format for display
    const [dateRangeEndDisplay, setDateRangeEndDisplay] = useState<string>(''); // DD/MM/YYYY format for display
    const [currentMonth, setCurrentMonth] = useState(new Date());
    
    const [historySort, setHistorySort] = useState('date-desc');
    const [historyFilterService, setHistoryFilterService] = useState('all');
    const [historyFilterTime, setHistoryFilterTime] = useState('all');
    const [historyFilterStatus, setHistoryFilterStatus] = useState('all');
    
    // Treatment Courses Filter States
    const [coursesFilterStatus, setCoursesFilterStatus] = useState<'active' | 'completed'>('active');
    
    // Review states - Use objects to store per-course data
    const [allReviews, setAllReviews] = useState<Review[]>([]);
    const [reviewingCourseId, setReviewingCourseId] = useState<string | null>(null);
    const [reviewRatings, setReviewRatings] = useState<{ [courseId: string]: number }>({});
    const [reviewHoverRatings, setReviewHoverRatings] = useState<{ [courseId: string]: number }>({});
    const [reviewComments, setReviewComments] = useState<{ [courseId: string]: string }>({});
    const [isSubmittingReview, setIsSubmittingReview] = useState<string | null>(null); // Store courseId being submitted

    // Fetch appointments from API to ensure we have the latest data
    useEffect(() => {
        const fetchAppointments = async () => {
            try {
                setIsLoadingAppointments(true);
                // Fetch user-specific appointments
                const userAppointments = await apiService.getUserAppointments(currentUser.id);
                setLocalAppointments(userAppointments);
            } catch (error) {
                console.error("Failed to fetch appointments:", error);
                // Fallback to allAppointments from props if API call fails
                const fallbackApps = allAppointments.filter(app => app.userId === currentUser.id);
                setLocalAppointments(fallbackApps);
            } finally {
                setIsLoadingAppointments(false);
            }
        };
        
        // Fetch immediately on mount
        fetchAppointments();
        
        // Set up polling every 10 seconds to auto-update appointments
        const interval = setInterval(() => {
            fetchAppointments();
        }, 10000); // 10 seconds
        
        // Also listen for refresh event
        const handleRefresh = () => {
            fetchAppointments();
        };
        window.addEventListener('refresh-appointments', handleRefresh);
        
        return () => {
            clearInterval(interval);
            window.removeEventListener('refresh-appointments', handleRefresh);
        };
    }, [currentUser.id, allAppointments]);

    // Fetch reviews when component mounts
    useEffect(() => {
        const fetchReviews = async () => {
            try {
                const reviews = await apiService.getReviews({ userId: currentUser.id });
                setAllReviews(reviews);
            } catch (error) {
                console.error('Error fetching reviews:', error);
            }
        };
        if (currentUser?.id) {
            fetchReviews();
        }
    }, [currentUser.id]);

    // Sync display values when dateRangeStart or dateRangeEnd changes
    useEffect(() => {
        if (dateRangeStart) {
            const formatted = formatDateDDMMYYYY(new Date(dateRangeStart)).replace(/-/g, '/');
            setDateRangeStartDisplay(formatted);
        } else {
            setDateRangeStartDisplay('');
        }
    }, [dateRangeStart]);

    useEffect(() => {
        if (dateRangeEnd) {
            const formatted = formatDateDDMMYYYY(new Date(dateRangeEnd)).replace(/-/g, '/');
            setDateRangeEndDisplay(formatted);
        } else {
            setDateRangeEndDisplay('');
        }
    }, [dateRangeEnd]);

    // Update local treatment courses when prop changes
    useEffect(() => {
        console.log('üìä allTreatmentCourses prop updated:', {
            count: allTreatmentCourses.length,
            courses: allTreatmentCourses.map(c => ({
                id: c.id,
                name: (c as any).serviceName || c.name,
                clientId: c.clientId,
                status: c.status,
                sessionsCount: c.sessions?.length || (c as any).TreatmentSessions?.length || 0
            }))
        });
        setLocalTreatmentCourses(allTreatmentCourses);
    }, [allTreatmentCourses]);

    // Fetch treatment courses from API to ensure we have latest data with sessions
    useEffect(() => {
        const fetchTreatmentCourses = async () => {
            try {
                // Fetch treatment courses for this client
                const clientCourses = await apiService.getTreatmentCourses({ clientId: currentUser.id });
                console.log('üìä Fetched treatment courses for client:', {
                    clientId: currentUser.id,
                    coursesCount: clientCourses.length,
                    courses: clientCourses.map(c => ({
                        id: c.id,
                        name: (c as any).serviceName || c.name,
                        status: c.status,
                        clientId: c.clientId,
                        sessionsCount: c.sessions?.length || (c as any).TreatmentSessions?.length || 0,
                        sessions: c.sessions || (c as any).TreatmentSessions
                    }))
                });
                
                // Update local state with fetched courses
                setLocalTreatmentCourses(clientCourses);
            } catch (error) {
                console.error("Failed to fetch treatment courses:", error);
            }
        };
        
        // Fetch immediately on mount
        fetchTreatmentCourses();
        
        // Set up polling every 30 seconds to auto-update
        const interval = setInterval(() => {
            fetchTreatmentCourses();
        }, 30000); // 30 seconds
        
        // Listen for refresh event
        const handleRefresh = () => {
            fetchTreatmentCourses();
        };
        window.addEventListener('refresh-treatment-courses', handleRefresh);
        
        return () => {
            clearInterval(interval);
            window.removeEventListener('refresh-treatment-courses', handleRefresh);
        };
    }, [currentUser.id]);

    // Also update when allAppointments changes (e.g., after booking)
    useEffect(() => {
        if (allAppointments.length > 0) {
            const userApps = allAppointments.filter(app => app.userId === currentUser.id);
            if (userApps.length > 0) {
                setLocalAppointments(prev => {
                    // Merge and deduplicate appointments
                    const merged = [...prev, ...userApps];
                    const unique = merged.filter((app, index, self) => 
                        index === self.findIndex(a => a.id === app.id)
                    );
                    return unique;
                });
            }
        }
    }, [allAppointments, currentUser.id]);

    const handleCancelAppointment = async () => {
        if (!appointmentToCancel) return;
        try {
            const cancelledAppointment = await apiService.cancelAppointment(appointmentToCancel.id);
            setLocalAppointments(prev =>
                prev.map(app => (app.id === cancelledAppointment.id ? cancelledAppointment : app))
            );
            setToastMessage('ƒê√£ h·ªßy l·ªãch h·∫πn th√†nh c√¥ng!');
            setTimeout(() => setToastMessage(null), 3000);
            setAppointmentToCancel(null);
        } catch (error) {
            console.error("Failed to cancel appointment:", error);
            alert("H·ªßy l·ªãch h·∫πn th·∫•t b·∫°i.");
        }
    };

    // --- Memoized Data Processing ---
    const { myUpcomingAppointments, myHistoryAppointments, myTreatmentCourses } = useMemo(() => {
        const now = new Date();
        // Filter appointments for current user
        const myApps = localAppointments.filter(app => app.userId === currentUser.id);

        // Upcoming appointments: include 'pending' (awaiting admin confirmation), 'upcoming' (confirmed), and 'in-progress'
        // Also include appointments that are in the future (even if status is pending)
        const upcoming = myApps
            .map(app => {
                // Preserve original date string to avoid timezone issues
                const originalDate = typeof app.date === 'string' ? app.date.split('T')[0] : app.date;
                // Create dateTime in local timezone
                const [hours, minutes] = app.time.split(':').map(Number);
                const [year, month, day] = originalDate.split('-').map(Number);
                const dateTime = new Date(year, month - 1, day, hours, minutes, 0, 0);
                return {...app, date: originalDate, dateTime };
            })
            .filter(app => {
                // Include if status is pending, upcoming, or in-progress
                const isUpcomingStatus = ['upcoming', 'pending', 'in-progress'].includes(app.status);
                // Also include if date is in the future (for appointments that might have been just created)
                const isFutureDate = app.dateTime >= now;
                return isUpcomingStatus && isFutureDate;
            });

        // History appointments: completed or cancelled, or past appointments regardless of status
        const history = myApps
            .map(app => ({...app, dateTime: new Date(`${app.date}T${app.time}`) }))
            .filter(app => {
                const isCompletedOrCancelled = ['completed', 'cancelled'].includes(app.status);
                const isPastDate = app.dateTime < now;
                // Include if completed/cancelled, or if past date (old appointments)
                return isCompletedOrCancelled || (isPastDate && !['upcoming', 'pending', 'in-progress'].includes(app.status));
            });

        const courses = localTreatmentCourses.filter(course => {
            const matches = course.clientId === currentUser.id;
                if (matches) {
                console.log('‚úÖ Found course for client:', {
                    courseId: course.id,
                    courseName: (course as any).serviceName || course.name,
                    clientId: course.clientId,
                    status: course.status,
                    sessionsCount: course.sessions?.length || 0,
                    hasSessions: !!course.sessions
                });
            }
            return matches;
        });
        
        console.log('üìä Treatment courses filter result:', {
            totalCourses: localTreatmentCourses.length,
            myCourses: courses.length,
            currentUserId: currentUser.id,
            courses: courses.map(c => ({ id: c.id, name: (c as any).serviceName || c.name, status: c.status, clientId: c.clientId, sessionsCount: c.sessions?.length || 0 }))
        });
        
        return { myUpcomingAppointments: upcoming, myHistoryAppointments: history, myTreatmentCourses: courses };
    }, [localAppointments, localTreatmentCourses, currentUser.id]);

    const reminders = useMemo(() => {
        const now = new Date();
        const twentyFourHoursFromNow = new Date(now.getTime() + 24 * 60 * 60 * 1000);
        
        return myUpcomingAppointments.filter(app => {
            // Create dateTime in local timezone to avoid timezone issues
            // app.date is in YYYY-MM-DD format, app.time is in HH:mm format
            const [hours, minutes] = app.time.split(':').map(Number);
            
            // Ensure app.date is a string in YYYY-MM-DD format
            let dateStr: string | Date = app.date;
            // Check if dateStr is a Date object using Object.prototype.toString
            const isDateObject = typeof dateStr === 'object' && dateStr !== null && Object.prototype.toString.call(dateStr) === '[object Date]';
            if (isDateObject) {
                const dateObj = dateStr as unknown as Date;
                const year = dateObj.getFullYear();
                const month = String(dateObj.getMonth() + 1).padStart(2, '0');
                const day = String(dateObj.getDate()).padStart(2, '0');
                dateStr = `${year}-${month}-${day}`;
            } else if (typeof dateStr === 'string') {
                // Remove any time portion if present
                dateStr = dateStr.split('T')[0];
            }
            
            // Parse date manually to avoid UTC timezone issues
            const [year, month, day] = dateStr.split('-').map(Number);
            const appointmentDate = new Date(year, month - 1, day, hours, minutes, 0, 0);
            
            // Check if appointment is within 24 hours from now
            return appointmentDate >= now && appointmentDate <= twentyFourHoursFromNow;
        });
    }, [myUpcomingAppointments]);

    // Helper function to get time range boundaries
    const getTimeRange = () => {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        today.setHours(0, 0, 0, 0);
        
        // Start of week (Monday)
        const startOfWeek = new Date(today);
        const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, ...
        const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
        startOfWeek.setDate(today.getDate() - daysToMonday);
        startOfWeek.setHours(0, 0, 0, 0);
        
        // End of week (Sunday)
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);
        endOfWeek.setHours(23, 59, 59, 999);
        
        // Start of month
        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        startOfMonth.setHours(0, 0, 0, 0);
        
        // End of month
        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        endOfMonth.setHours(23, 59, 59, 999);
        
        return { today, startOfWeek, endOfWeek, startOfMonth, endOfMonth };
    };

    const filterByTime = (apps: (Appointment & { dateTime: Date })[], timeFilter: string) => {
        const { today, startOfWeek, endOfWeek, startOfMonth, endOfMonth } = getTimeRange();

        switch (timeFilter) {
            case 'today':
                // Filter appointments that fall within today (00:00:00 to 23:59:59)
                return apps.filter(app => {
                    const appDate = new Date(app.dateTime);
                    appDate.setHours(0, 0, 0, 0);
                    return appDate.getTime() === today.getTime();
                });
            case 'this-week':
                // Filter appointments that fall within this week (Monday to Sunday)
                return apps.filter(app => {
                    const appDateTime = app.dateTime.getTime();
                    return appDateTime >= startOfWeek.getTime() && appDateTime <= endOfWeek.getTime();
                });
            case 'this-month':
                // Filter appointments that fall within this month
                return apps.filter(app => {
                    const appDateTime = app.dateTime.getTime();
                    return appDateTime >= startOfMonth.getTime() && appDateTime <= endOfMonth.getTime();
                });
            case 'all':
            default:
                return apps;
        }
    };
    
    // Filter treatment courses by status (active or completed)
    const filterCoursesByStatus = (courses: TreatmentCourse[], statusFilter: 'active' | 'completed') => {
        if (statusFilter === 'active') {
            // Show active, pending courses (courses that are not completed or expired)
            return courses.filter(course => 
                course.status === 'active' || course.status === 'pending'
            );
        } else {
            // Show completed courses ONLY when progress is 100%
            return courses.filter(course => {
                // Compute progress from available fields
                const totalSessions = course.totalSessions ?? (Array.isArray(course.sessions) ? course.sessions.length : (Array.isArray((course as any).TreatmentSessions) ? (course as any).TreatmentSessions.length : 0));
                let completedSessions = course.completedSessions ?? 0;

                if (completedSessions === 0) {
                    // Try counting from session objects if available
                    const sessionsArr = course.sessions ?? (course as any).TreatmentSessions;
                    if (Array.isArray(sessionsArr) && sessionsArr.length > 0) {
                        completedSessions = sessionsArr.filter((s: any) => s.status === 'completed').length;
                    }
                }

                // Compute actual progress percentage
                let progressPct = 0;
                if (totalSessions && totalSessions > 0) {
                    progressPct = Math.round((completedSessions / totalSessions) * 100);
                } else if (typeof (course as any).progressPercentage === 'number') {
                    progressPct = (course as any).progressPercentage;
                }

                // STRICT: Only show if progress is exactly 100%
                // Reject 0% or any incomplete course, even with status='completed'
                return progressPct >= 100 && totalSessions > 0 && completedSessions > 0;
            });
        }
    };
    
    // Legacy function - kept for compatibility but not used
    const filterCoursesByTime = (courses: TreatmentCourse[], timeFilter: string) => {
        if (timeFilter === 'all') return courses;
        
        const { today, startOfWeek, endOfWeek, startOfMonth, endOfMonth } = getTimeRange();
        
        return courses.filter(course => {
            // Check if course has sessions with dates in the time range
            if (course.sessions && Array.isArray(course.sessions) && course.sessions.length > 0) {
                const hasSessionInRange = course.sessions.some(session => {
                    if (!session.date) return false;
                    const sessionDate = new Date(session.date);
                    sessionDate.setHours(0, 0, 0, 0);
                    
                    switch (timeFilter) {
                        case 'today':
                            return sessionDate.getTime() === today.getTime();
                        case 'this-week':
                            return sessionDate.getTime() >= startOfWeek.getTime() && sessionDate.getTime() <= endOfWeek.getTime();
                        case 'this-month':
                            return sessionDate.getTime() >= startOfMonth.getTime() && sessionDate.getTime() <= endOfMonth.getTime();
                        default:
                            return false;
                    }
                });
                if (hasSessionInRange) return true;
            }
            
            // Check nextAppointmentDate if available
            if (course.nextAppointmentDate) {
                const nextDate = new Date(course.nextAppointmentDate);
                nextDate.setHours(0, 0, 0, 0);
                
                switch (timeFilter) {
                    case 'today':
                        return nextDate.getTime() === today.getTime();
                    case 'this-week':
                        return nextDate.getTime() >= startOfWeek.getTime() && nextDate.getTime() <= endOfWeek.getTime();
                    case 'this-month':
                        return nextDate.getTime() >= startOfMonth.getTime() && nextDate.getTime() <= endOfMonth.getTime();
                    default:
                        return false;
                }
            }
            
            return false;
        });
    };

    // Group appointments by date
    const groupAppointmentsByDate = (appointments: (Appointment & { dateTime: Date })[]) => {
        const grouped: Record<string, (Appointment & { dateTime: Date })[]> = {};
        appointments.forEach(app => {
            const dateString = app.dateTime.toLocaleDateString('vi-VN', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' });
            if (!grouped[dateString]) {
                grouped[dateString] = [];
            }
            grouped[dateString].push(app);
        });
        return grouped;
    };
    
    const displayUpcoming = useMemo(() => {
        let filtered = [...myUpcomingAppointments];
        
        if (upcomingFilterService !== 'all') {
            filtered = filtered.filter(app => app.serviceId === upcomingFilterService);
        }
        
        // Filter by date range if provided
        if (dateRangeStart && dateRangeEnd) {
            const startDate = new Date(dateRangeStart);
            startDate.setHours(0, 0, 0, 0);
            const endDate = new Date(dateRangeEnd);
            endDate.setHours(23, 59, 59, 999);
            
            filtered = filtered.filter(app => {
                const appDate = new Date(app.dateTime);
                return appDate >= startDate && appDate <= endDate;
            });
        } else {
            // If no date range, use time filter
            filtered = filterByTime(filtered, upcomingFilterTime);
        }

        filtered.sort((a, b) => upcomingSort === 'date-asc' ? a.dateTime.getTime() - b.dateTime.getTime() : b.dateTime.getTime() - a.dateTime.getTime());
        
        return filtered;
    }, [myUpcomingAppointments, upcomingSort, upcomingFilterService, upcomingFilterTime, dateRangeStart, dateRangeEnd]);
    
    const displayHistory = useMemo(() => {
        let filtered = [...myHistoryAppointments];
        
        if (historyFilterService !== 'all') {
            filtered = filtered.filter(app => app.serviceId === historyFilterService);
        }
        
        if (historyFilterStatus !== 'all') {
            filtered = filtered.filter(app => app.status === historyFilterStatus);
        }

        filtered = filterByTime(filtered, historyFilterTime);
        
        filtered.sort((a, b) => historySort === 'date-desc' ? b.dateTime.getTime() - a.dateTime.getTime() : a.dateTime.getTime() - b.dateTime.getTime());
        
        return filtered;
    }, [myHistoryAppointments, historySort, historyFilterService, historyFilterTime, historyFilterStatus]);

    const uniqueServiceIds = useMemo(() => [...new Set(myUpcomingAppointments.map(a => a.serviceId).concat(myHistoryAppointments.map(a => a.serviceId)))], [myUpcomingAppointments, myHistoryAppointments]);
    const serviceFilterOptions = allServices.filter(s => uniqueServiceIds.includes(s.id));
    
    // Filter treatment courses by status
    const displayCourses = useMemo(() => {
        return filterCoursesByStatus(myTreatmentCourses, coursesFilterStatus);
    }, [myTreatmentCourses, coursesFilterStatus]);

    // --- Render Functions for Cards ---

    const UpcomingAppointmentCard: React.FC<{ appointment: Appointment & { dateTime: Date } }> = ({ appointment }) => {
        // Determine status badge based on appointment status
        const getStatusBadge = () => {
            if (appointment.status === 'pending') {
                return <span className="px-3 py-1 text-xs font-bold rounded-full bg-yellow-100 text-yellow-800 flex-shrink-0">Ch·ªù x√°c nh·∫≠n</span>;
            } else if (appointment.status === 'upcoming') {
                return <span className="px-3 py-1 text-xs font-bold rounded-full bg-blue-100 text-blue-800 flex-shrink-0">ƒê√£ x√°c nh·∫≠n</span>;
            } else if (appointment.status === 'in-progress') {
                return <span className="px-3 py-1 text-xs font-bold rounded-full bg-purple-100 text-purple-800 flex-shrink-0">ƒêang ti·∫øn h√†nh</span>;
            }
            return null;
        };

        return (
            <div className="bg-white p-5 rounded-lg shadow-soft-lg border border-gray-100">
                <div className="flex justify-between items-start">
                    <div>
                        <p className="text-sm font-semibold text-gray-600 mb-2">
                            {appointment.time}
                        </p>
                        <h4 className="text-xl font-bold font-serif text-brand-text">{appointment.serviceName}</h4>
                    </div>
                    {getStatusBadge()}
                </div>
                <div className="border-t mt-4 pt-4 flex justify-end items-center gap-3">
                    <button onClick={() => setViewingAppointment(appointment)} className="px-4 py-2 text-sm font-semibold bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200">Xem Chi Ti·∫øt</button>
                    {appointment.status !== 'pending' && (
                        <button 
                            onClick={() => setAppointmentToCancel(appointment)} 
                            disabled={appointment.status === 'upcoming'}
                            className={`px-4 py-2 text-sm font-semibold rounded-md ${
                                appointment.status === 'upcoming'
                                    ? 'bg-gray-200 text-gray-400 cursor-not-allowed'
                                    : 'bg-red-50 text-red-700 hover:bg-red-100'
                            }`}
                        >
                            H·ªßy l·ªãch
                        </button>
                    )}
                </div>
            </div>
        );
    };

    const HistoryAppointmentCard: React.FC<{ appointment: Appointment & { dateTime: Date } }> = ({ appointment }) => {
        const therapistName = appointment.Therapist?.name || (allUsers.find(u => u.id === appointment.therapistId)?.name) || 'Kh√¥ng c√≥';
        return (
            <div className="bg-white p-5 rounded-lg shadow-soft-lg border border-gray-100 flex justify-between items-center">
                <div>
                    <p className="text-sm font-semibold text-brand-dark">{appointment.dateTime.toLocaleDateString('vi-VN', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })} - {appointment.time}</p>
                    <h4 className="text-xl font-bold font-serif text-brand-text mt-1">{appointment.serviceName}</h4>
                    <p className="text-xs text-gray-500 mt-1">K·ªπ thu·∫≠t vi√™n: {therapistName}</p>
                </div>
                <div className="flex flex-col items-end gap-3">
                    <span className={`px-3 py-1 text-xs font-bold rounded-full ${appointment.status === 'completed' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                        {appointment.status === 'completed' ? 'Ho√†n th√†nh' : 'ƒê√£ h·ªßy'}
                    </span>
                    <div className="flex items-center gap-3">
                        <button onClick={() => setViewingAppointment(appointment)} className="px-4 py-2 text-sm font-semibold bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200">Xem Chi Ti·∫øt</button>
                        {appointment.status === 'completed' && (
                            <>
                                <button onClick={() => navigate(`/service/${appointment.serviceId}`)} className="text-sm font-semibold text-green-600 hover:underline">ƒê√°nh gi√°</button>
                                <button onClick={() => navigate(`/booking?serviceId=${appointment.serviceId}`)} className="px-4 py-2 text-sm font-semibold bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200">ƒê·∫∑t l·∫°i</button>
                            </>
                        )}
                    </div>
                </div>
            </div>
        );
    };
    
    const TreatmentCourseCard: React.FC<{ course: TreatmentCourse }> = ({ course }) => {
        // Use ref to preserve textarea reference and cursor position
        const textareaRef = useRef<HTMLTextAreaElement>(null);
        const cursorPositionRef = useRef<number | null>(null);
        // Use ref to store comment value to avoid re-render issues
        const commentValueRef = useRef<string>('');
        
        const sessions = course.sessions || [];
        const completedSessions = sessions.filter(s => s.status === 'completed').length;
        const progress = course.totalSessions > 0 ? (completedSessions / course.totalSessions) * 100 : 0;
        const firstService = course.services && course.services.length > 0 ? course.services[0] : null;
        const isCompleted = completedSessions === course.totalSessions && course.totalSessions > 0;
        const pendingSessions = sessions.filter(s => s.status === 'pending').length;
        const scheduledSessions = sessions.filter(s => s.status === 'scheduled').length;
        
        // Find current session (next uncompleted session)
        const currentSession = sessions
            .sort((a, b) => a.sessionNumber - b.sessionNumber)
            .find(s => s.status !== 'completed');
        
        // Find previous completed session to get admin notes
        const previousSession = sessions
            .filter(s => s.status === 'completed')
            .sort((a, b) => b.sessionNumber - a.sessionNumber)[0]; // Get most recent completed session
        
        // Get notes from current session or previous session (map to available fields)
        const adminNotes = currentSession?.therapistNotes || previousSession?.therapistNotes;
        const customerStatusNotes = currentSession?.notes || previousSession?.notes;
        
        return (
            <div 
                className={`bg-white p-6 rounded-lg shadow-lg border-2 transition-all hover:shadow-xl ${
                    isCompleted 
                        ? 'border-green-400 bg-green-50' 
                        : 'border-brand-primary hover:border-brand-dark'
                }`}
            >
                <div className="flex justify-between items-start mb-4">
                    <div className="flex-1">
                        <h4 className="text-xl font-bold font-serif text-brand-text mb-2">{(course as any).serviceName || course.name}</h4>
                        <div className="flex flex-wrap gap-2 text-sm mb-3">
                            <span className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full font-semibold">
                                {course.totalSessions} bu·ªïi
                            </span>
                            {completedSessions > 0 && (
                                <span className="px-3 py-1 bg-green-100 text-green-800 rounded-full font-semibold">
                                    ‚úì {completedSessions} ho√†n th√†nh
                                </span>
                            )}
                            {scheduledSessions > 0 && (
                                <span className="px-3 py-1 bg-yellow-100 text-yellow-800 rounded-full font-semibold">
                                    üìÖ {scheduledSessions} ƒë√£ ƒë·∫∑t l·ªãch
                                </span>
                            )}
                            {pendingSessions > 0 && (
                                <span className="px-3 py-1 bg-orange-100 text-orange-800 rounded-full font-semibold">
                                    ‚è≥ {pendingSessions} ch·ªù ƒë·∫∑t l·ªãch
                                </span>
                            )}
                        </div>
                        
                        {/* Current Session Info */}
                        {!isCompleted && currentSession && (
                            <div className="bg-purple-50 border border-purple-200 rounded-lg p-3 mb-3">
                                <div className="flex items-center gap-2 mb-2">
                                    <span className="text-lg font-bold text-purple-800">üìå Bu·ªïi hi·ªán t·∫°i: Bu·ªïi {currentSession.sessionNumber}</span>
                                </div>
                                {((currentSession.date) || (currentSession as any).scheduledDate) && (
                                    <p className="text-sm text-gray-700 mb-1">
                                        <strong>Ng√†y:</strong> {new Date(currentSession.date || (currentSession as any).scheduledDate).toLocaleDateString('vi-VN')}
                                        {(currentSession as any).scheduledTime && ` - ${(currentSession as any).scheduledTime}`}
                                    </p>
                                )}
                                {(currentSession.therapistId || (currentSession as any).therapistName) && (
                                    <p className="text-sm text-gray-700">
                                        <strong>K·ªπ thu·∫≠t vi√™n:</strong> ƒê√£ ƒë∆∞·ª£c ph√¢n c√¥ng
                                    </p>
                                )}
                            </div>
                        )}
                        
                        {/* Admin Notes Section - Only show customer status notes to client */}
                        {customerStatusNotes && (
                            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-3">
                                <p className="text-sm font-semibold text-yellow-800 mb-2">
                                    üìù Ghi ch√∫ t·ª´ admin {currentSession ? `(Bu·ªïi ${currentSession.sessionNumber})` : previousSession ? `(Bu·ªïi ${previousSession.sessionNumber})` : ''}
                                </p>
                                <div>
                                    <p className="text-xs text-gray-600 mb-1">
                                        <span className="text-gray-600">[Kh√°ch h√†ng]</span> Ghi ch√∫ t√¨nh tr·∫°ng:
                                    </p>
                                    <p className="text-sm text-gray-800 bg-white p-2 rounded border whitespace-pre-wrap">{customerStatusNotes}</p>
                                </div>
                            </div>
                        )}
                    </div>
                    <div className="text-right ml-4">
                        <div className="text-3xl font-bold text-brand-primary">{Math.round(progress)}%</div>
                        <div className="text-xs text-gray-500">Ti·∫øn ƒë·ªô</div>
                    </div>
                </div>
                
                <div className="w-full bg-gray-200 rounded-full h-3 mb-4 overflow-hidden">
                    <div 
                        className="bg-gradient-to-r from-brand-primary to-amber-500 h-3 rounded-full transition-all duration-500" 
                        style={{ width: `${progress}%` }}
                    ></div>
                </div>
                
                {isCompleted && (
                    <>
                        <div className="mb-4 p-3 bg-green-100 border border-green-300 rounded-lg">
                            <p className="text-green-800 font-semibold text-center">
                                üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh li·ªáu tr√¨nh!
                            </p>
                        </div>
                        
                        {/* Review Section */}
                        {(() => {
                            const serviceId = (course as any).serviceId
                                ?? (course as any).Service?.id
                                ?? (course as any).service?.id
                                ?? (Array.isArray((course as any).services) && course.services.length > 0 ? (course.services[0].serviceId ?? (course.services[0] as any).id) : undefined)
                                ?? undefined;
                            const existingReview = allReviews.find(r => r.serviceId === serviceId);
                            const isReviewing = reviewingCourseId === course.id;
                            
                            if (existingReview) {
                                // User has already reviewed
                                return (
                                    <div className="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                                        <p className="text-sm font-semibold text-blue-800 mb-2">‚úÖ B·∫°n ƒë√£ ƒë√°nh gi√° d·ªãch v·ª• n√†y</p>
                                        <div className="flex items-center gap-2 mb-2">
                                            <div className="flex text-yellow-400">
                                                {[...Array(5)].map((_, i) => (
                                                    <StarIcon key={i} className={`w-5 h-5 ${i < existingReview.rating ? 'fill-current' : 'text-gray-300'}`} />
                                                ))}
                                            </div>
                                            <span className="text-sm text-gray-600">{new Date(existingReview.date).toLocaleDateString('vi-VN')}</span>
                                        </div>
                                        {existingReview.comment && (
                                            <p className="text-sm text-gray-700 italic">"{existingReview.comment}"</p>
                                        )}
                                        <button
                                            onClick={() => navigate(`/service/${serviceId}`)}
                                            className="mt-2 text-sm text-blue-600 hover:underline"
                                        >
                                            Xem ƒë√°nh gi√° c·ªßa b·∫°n ‚Üí
                                        </button>
                                    </div>
                                );
                            }
                            
                            if (isReviewing) {
                                // Get current values for this course
                                const currentRating = reviewRatings[course.id] || 0;
                                const currentHoverRating = reviewHoverRatings[course.id] || 0;
                                const currentComment = reviewComments[course.id] || '';
                                const isSubmitting = isSubmittingReview === course.id;
                                
                                // Sync local comment with parent state only when form opens/closes
                                // Don't use useEffect to avoid resetting while user is typing
                                
                                // Show review form
                                return (
                                    <div className="mt-4 p-4 bg-white border border-gray-300 rounded-lg">
                                        <h5 className="text-lg font-semibold text-gray-800 mb-3">ƒê√°nh gi√° v√† ph·∫£n h·ªìi ch·∫•t l∆∞·ª£ng d·ªãch v·ª•</h5>
                                        
                                        {/* Star Rating */}
                                        <div className="mb-4">
                                            <label className="block text-sm font-medium text-gray-700 mb-2">ƒê√°nh gi√° sao *</label>
                                            <div className="flex gap-1">
                                                {[1, 2, 3, 4, 5].map((star) => (
                                                    <button
                                                        key={star}
                                                        type="button"
                                                        onClick={() => {
                                                            setReviewRatings(prev => ({ ...prev, [course.id]: star }));
                                                        }}
                                                        onMouseEnter={() => {
                                                            setReviewHoverRatings(prev => ({ ...prev, [course.id]: star }));
                                                        }}
                                                        onMouseLeave={() => {
                                                            setReviewHoverRatings(prev => ({ ...prev, [course.id]: 0 }));
                                                        }}
                                                        className="focus:outline-none"
                                                    >
                                                        <StarIcon
                                                            className={`w-8 h-8 transition-colors ${
                                                                star <= (currentHoverRating || currentRating)
                                                                    ? 'text-yellow-400 fill-current'
                                                                    : 'text-gray-300'
                                                            }`}
                                                        />
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                        
                                        {/* Comment */}
                                        <div className="mb-4">
                                            <label className="block text-sm font-medium text-gray-700 mb-2">Nh·∫≠n x√©t (t√πy ch·ªçn)</label>
                                            <textarea
                                                ref={textareaRef}
                                                defaultValue={commentValueRef.current}
                                                onChange={(e) => {
                                                    // Update ref value only - no state update, no re-render
                                                    const textarea = e.target as HTMLTextAreaElement;
                                                    commentValueRef.current = textarea.value;
                                                    
                                                    // Preserve cursor position
                                                    const cursorPos = textarea.selectionStart;
                                                    requestAnimationFrame(() => {
                                                        if (textareaRef.current) {
                                                            textareaRef.current.setSelectionRange(cursorPos, cursorPos);
                                                        }
                                                    });
                                                }}
                                                onKeyDown={(e) => {
                                                    // Prevent any selection issues
                                                    const textarea = e.target as HTMLTextAreaElement;
                                                    if (textarea.selectionStart !== textarea.selectionEnd) {
                                                        // If text is selected, allow normal behavior
                                                        return;
                                                    }
                                                }}
                                                rows={4}
                                                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-amber-500 resize-none"
                                                placeholder="Chia s·∫ª tr·∫£i nghi·ªám c·ªßa b·∫°n v·ªÅ d·ªãch v·ª• n√†y..."
                                                autoFocus
                                            />
                                        </div>
                                        
                                        {/* Buttons */}
                                        <div className="flex gap-2">
                                            <button
                                                onClick={async () => {
                                                    if (currentRating === 0) {
                                                        alert('Vui l√≤ng ch·ªçn s·ªë sao ƒë√°nh gi√°');
                                                        return;
                                                    }
                                                    
                                                    // Get comment value from textarea or ref
                                                    const commentValue = textareaRef.current?.value || commentValueRef.current || '';
                                                    
                                                    // Sync comment to parent state before submit
                                                    setReviewComments(prev => ({ ...prev, [course.id]: commentValue }));
                                                    
                                                    setIsSubmittingReview(course.id);
                                                    try {
                                                        const service = allServices.find(s => s.id === serviceId);
                                                        await apiService.createReview({
                                                            userId: currentUser.id,
                                                            serviceId: serviceId,
                                                            rating: currentRating,
                                                            comment: commentValue.trim() || null,
                                                            serviceName: service?.name,
                                                            userName: currentUser.name,
                                                            userImageUrl: currentUser.profilePictureUrl || '',
                                                        });
                                                        
                                                        // Refresh reviews
                                                        const reviews = await apiService.getReviews({ userId: currentUser.id });
                                                        setAllReviews(reviews);
                                                        
                                                        // Reset form for this course
                                                        setReviewingCourseId(null);
                                                        setReviewRatings(prev => {
                                                            const newRatings = { ...prev };
                                                            delete newRatings[course.id];
                                                            return newRatings;
                                                        });
                                                        setReviewHoverRatings(prev => {
                                                            const newHoverRatings = { ...prev };
                                                            delete newHoverRatings[course.id];
                                                            return newHoverRatings;
                                                        });
                                                        setReviewComments(prev => {
                                                            const newComments = { ...prev };
                                                            delete newComments[course.id];
                                                            return newComments;
                                                        });
                                                        
                                                        // Reset comment ref
                                                        commentValueRef.current = '';
                                                        
                                                        setToastMessage('C·∫£m ∆°n b·∫°n ƒë√£ ƒë√°nh gi√°!');
                                                        setTimeout(() => setToastMessage(null), 3000);
                                                    } catch (error: any) {
                                                        console.error('Error submitting review:', error);
                                                        alert(error.message || 'C√≥ l·ªói x·∫£y ra khi g·ª≠i ƒë√°nh gi√°');
                                                    } finally {
                                                        setIsSubmittingReview(null);
                                                    }
                                                }}
                                                disabled={isSubmitting || currentRating === 0}
                                                className="px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                            >
                                                {isSubmitting ? 'ƒêang g·ª≠i...' : 'G·ª≠i ƒë√°nh gi√°'}
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setReviewingCourseId(null);
                                                    setReviewRatings(prev => {
                                                        const newRatings = { ...prev };
                                                        delete newRatings[course.id];
                                                        return newRatings;
                                                    });
                                                    setReviewHoverRatings(prev => {
                                                        const newHoverRatings = { ...prev };
                                                        delete newHoverRatings[course.id];
                                                        return newHoverRatings;
                                                    });
                                                    setReviewComments(prev => {
                                                        const newComments = { ...prev };
                                                        delete newComments[course.id];
                                                        return newComments;
                                                    });
                                                    // Reset comment ref
                                                    commentValueRef.current = '';
                                                }}
                                                disabled={isSubmitting}
                                                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 disabled:bg-gray-100"
                                            >
                                                H·ªßy
                                            </button>
                                        </div>
                                    </div>
                                );
                            }
                            
                            // Show button to start reviewing
                            return (
                                <div className="mt-4">
                                    <button
                                        onClick={() => {
                                            setReviewingCourseId(course.id);
                                            setReviewRatings(prev => ({ ...prev, [course.id]: 0 }));
                                            setReviewHoverRatings(prev => ({ ...prev, [course.id]: 0 }));
                                            setReviewComments(prev => ({ ...prev, [course.id]: '' }));
                                            // Initialize comment ref when form opens
                                            const savedComment = reviewComments[course.id] || '';
                                            commentValueRef.current = savedComment;
                                            // Set textarea value directly and preserve cursor position
                                            setTimeout(() => {
                                                if (textareaRef.current) {
                                                    textareaRef.current.value = savedComment;
                                                    const len = savedComment.length;
                                                    textareaRef.current.setSelectionRange(len, len);
                                                    textareaRef.current.focus();
                                                }
                                            }, 0);
                                        }}
                                        className="w-full px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 font-semibold"
                                    >
                                        ‚≠ê ƒê√°nh gi√° v√† ph·∫£n h·ªìi ch·∫•t l∆∞·ª£ng d·ªãch v·ª•
                                    </button>
                                </div>
                            );
                        })()}
                    </>
                )}
            </div>
        );
    };

    return (
        <div className="bg-brand-secondary min-h-screen">
            {toastMessage && (
                <div className="fixed top-28 right-6 bg-green-500 text-white p-4 rounded-lg shadow-lg z-[100] animate-fadeInDown">
                    {toastMessage}
                </div>
            )}
            <div className="container mx-auto px-4 py-12">
                <h1 className="text-3xl sm:text-4xl font-serif font-bold text-brand-text text-center mb-10">L·ªãch H·∫πn & Li·ªáu Tr√¨nh</h1>

                <div className="mb-8 flex justify-center border-b border-gray-300">
                    <button onClick={() => setActiveTab('upcoming')} className={`px-6 py-3 font-semibold text-lg transition-colors ${activeTab === 'upcoming' ? 'border-b-2 border-brand-primary text-brand-dark' : 'text-gray-500 hover:text-brand-dark'}`}>L·ªãch H·∫πn S·∫Øp T·ªõi</button>
                    <button onClick={() => setActiveTab('history')} className={`px-6 py-3 font-semibold text-lg transition-colors ${activeTab === 'history' ? 'border-b-2 border-brand-primary text-brand-dark' : 'text-gray-500 hover:text-brand-dark'}`}>L·ªãch S·ª≠ H·∫πn</button>
                    <button onClick={() => setActiveTab('courses')} className={`px-6 py-3 font-semibold text-lg transition-colors ${activeTab === 'courses' ? 'border-b-2 border-brand-primary text-brand-dark' : 'text-gray-500 hover:text-brand-dark'}`}>Li·ªáu Tr√¨nh C·ªßa T√¥i</button>
                </div>
                
                <div className="max-w-5xl mx-auto">
                    {activeTab === 'upcoming' && (
                        <div className="space-y-6">
                            <div className="bg-white p-4 rounded-lg shadow-md grid grid-cols-1 md:grid-cols-3 gap-4 items-center">
                                <div className="flex flex-col gap-2">
                                    <label className="text-sm font-medium text-gray-700">Xem l·ªãch t·ª´ (dd/mm/yyyy)</label>
                                    <div className="relative">
                                        <input
                                            type="date"
                                            value={dateRangeStart}
                                            onChange={(e) => {
                                                const yyyyMMdd = e.target.value;
                                                setDateRangeStart(yyyyMMdd);
                                                if (yyyyMMdd) {
                                                    const formatted = formatDateDDMMYYYY(new Date(yyyyMMdd)).replace(/-/g, '/');
                                                    setDateRangeStartDisplay(formatted);
                                                } else {
                                                    setDateRangeStartDisplay('');
                                                }
                                                setUpcomingFilterTime('all'); // Clear time filter when using date range
                                            }}
                                            className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
                                        />
                                        <div className="w-full p-2 pr-10 border rounded-md bg-white pointer-events-none flex items-center min-h-[42px]">
                                            <span className={dateRangeStartDisplay ? 'text-gray-800' : 'text-gray-400'}>
                                                {dateRangeStartDisplay || 'dd/mm/yyyy'}
                                            </span>
                                            <svg
                                                className="absolute right-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400 pointer-events-none"
                                                fill="none"
                                                stroke="currentColor"
                                                viewBox="0 0 24 24"
                                            >
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                                <div className="flex flex-col gap-2">
                                    <label className="text-sm font-medium text-gray-700">ƒë·∫øn (dd/mm/yyyy)</label>
                                    <div className="relative">
                                        <input
                                            type="date"
                                            value={dateRangeEnd}
                                            onChange={(e) => {
                                                const yyyyMMdd = e.target.value;
                                                setDateRangeEnd(yyyyMMdd);
                                                if (yyyyMMdd) {
                                                    const formatted = formatDateDDMMYYYY(new Date(yyyyMMdd)).replace(/-/g, '/');
                                                    setDateRangeEndDisplay(formatted);
                                                } else {
                                                    setDateRangeEndDisplay('');
                                                }
                                                setUpcomingFilterTime('all'); // Clear time filter when using date range
                                            }}
                                            min={dateRangeStart || undefined}
                                            className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
                                        />
                                        <div className="w-full p-2 pr-10 border rounded-md bg-white pointer-events-none flex items-center min-h-[42px]">
                                            <span className={dateRangeEndDisplay ? 'text-gray-800' : 'text-gray-400'}>
                                                {dateRangeEndDisplay || 'dd/mm/yyyy'}
                                            </span>
                                            <svg
                                                className="absolute right-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400 pointer-events-none"
                                                fill="none"
                                                stroke="currentColor"
                                                viewBox="0 0 24 24"
                                            >
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                                <select value={upcomingFilterService} onChange={e => setUpcomingFilterService(e.target.value)} className="w-full p-2 border rounded-md bg-white">
                                    <option value="all">L·ªçc theo d·ªãch v·ª•</option>
                                    {serviceFilterOptions.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}
                                </select>
                            </div>
                            
                            {reminders.length > 0 && (
                                <div className="bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800 p-4 rounded-md flex gap-3">
                                    <BellIcon className="w-6 h-6 text-yellow-500 flex-shrink-0 mt-1"/>
                                    <div>
                                        <h4 className="font-bold">Nh·∫Øc nh·ªü l·ªãch h·∫πn!</h4>
                                        <p className="text-sm">B·∫°n c√≥ l·ªãch h·∫πn sau ƒë√¢y trong v√≤ng 24 gi·ªù t·ªõi:</p>
                                        <ul className="list-disc list-inside text-sm mt-1">
                                            {reminders.map(app => {
                                                // Format date correctly using app.date (YYYY-MM-DD) to avoid timezone issues
                                                // app.date is guaranteed to be in YYYY-MM-DD format from the API
                                                // Handle both string and Date object cases
                                                let dateStr = app.date;
                                                
                                                // Debug: log original date value
                                                const isDateObj = typeof app.date === 'object' && app.date !== null && Object.prototype.toString.call(app.date) === '[object Date]';
                                                console.log('Reminder date debug:', {
                                                    originalDate: app.date,
                                                    dateType: typeof app.date,
                                                    isDate: isDateObj,
                                                    serviceName: app.serviceName,
                                                    time: app.time
                                                });
                                                
                                                // Check if dateStr is a Date object using Object.prototype.toString
                                                const isDateObject = typeof dateStr === 'object' && dateStr !== null && Object.prototype.toString.call(dateStr) === '[object Date]';
                                                if (isDateObject) {
                                                    // If it's a Date object, convert to YYYY-MM-DD string using local timezone
                                                    const dateObj = dateStr as unknown as Date;
                                                    const year = dateObj.getFullYear();
                                                    const month = String(dateObj.getMonth() + 1).padStart(2, '0');
                                                    const day = String(dateObj.getDate()).padStart(2, '0');
                                                    dateStr = `${year}-${month}-${day}`;
                                                } else if (typeof dateStr === 'string') {
                                                    // If it's already a string, use it directly
                                                    // Remove any time portion if present (e.g., "2025-11-30T00:00:00.000Z" -> "2025-11-30")
                                                    dateStr = dateStr.split('T')[0];
                                                }
                                                
                                                const dateParts = dateStr.split('-');
                                                if (dateParts.length === 3) {
                                                    const formattedDate = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`;
                                                    console.log('Formatted reminder date:', {
                                                        original: app.date,
                                                        processed: dateStr,
                                                        formatted: formattedDate
                                                    });
                                                    return (
                                                        <li key={app.id}>
                                                            <strong>{app.serviceName}</strong> l√∫c {app.time} ng√†y {formattedDate}
                                                        </li>
                                                    );
                                                } else {
                                                    // Fallback: use original date string
                                                    return (
                                                        <li key={app.id}>
                                                            <strong>{app.serviceName}</strong> l√∫c {app.time} ng√†y {dateStr}
                                                        </li>
                                                    );
                                                }
                                            })}
                                        </ul>
                                    </div>
                                </div>
                            )}

                            {isLoadingAppointments ? (
                                <div className="text-center py-10">
                                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-brand-primary mx-auto mb-4"></div>
                                    <p className="text-gray-500">ƒêang t·∫£i l·ªãch h·∫πn...</p>
                                </div>
                            ) : displayUpcoming.length > 0 ? (
                                (() => {
                                    // Render calendar view
                                    const year = currentMonth.getFullYear();
                                    const month = currentMonth.getMonth();
                                    
                                    // Get first day of month and how many days
                                    const firstDay = new Date(year, month, 1);
                                    const lastDay = new Date(year, month + 1, 0);
                                    const daysInMonth = lastDay.getDate();
                                    const startingDayOfWeek = firstDay.getDay();
                                    
                                    // Adjust for Monday as first day (0 = Monday, 6 = Sunday)
                                    const adjustedStartingDay = startingDayOfWeek === 0 ? 6 : startingDayOfWeek - 1;
                                    
                                    const days: (Date | null)[] = [];
                                    
                                    // Add empty cells for days before month starts
                                    for (let i = 0; i < adjustedStartingDay; i++) {
                                        days.push(null);
                                    }
                                    
                                    // Add all days of the month
                                    for (let day = 1; day <= daysInMonth; day++) {
                                        days.push(new Date(year, month, day));
                                    }
                                    
                                    // Group appointments by date
                                    const appointmentsByDate = new Map<string, (Appointment & { dateTime: Date })[]>();
                                    displayUpcoming.forEach(app => {
                                        // Ensure app.date is in YYYY-MM-DD format
                                        let dateKey = app.date;
                                        if (typeof dateKey === 'string') {
                                            dateKey = dateKey.split('T')[0]; // Remove time portion if present
                                        } else {
                                            // If it's a Date object, format it
                                            const isDateObject = typeof dateKey === 'object' && dateKey !== null && Object.prototype.toString.call(dateKey) === '[object Date]';
                                            if (isDateObject) {
                                                const dateObj = dateKey as unknown as Date;
                                                const year = dateObj.getFullYear();
                                                const month = String(dateObj.getMonth() + 1).padStart(2, '0');
                                                const day = String(dateObj.getDate()).padStart(2, '0');
                                                dateKey = `${year}-${month}-${day}`;
                                            } else {
                                                dateKey = String(dateKey).split('T')[0];
                                            }
                                        }
                                        if (!appointmentsByDate.has(dateKey)) {
                                            appointmentsByDate.set(dateKey, []);
                                        }
                                        appointmentsByDate.get(dateKey)!.push(app);
                                    });
                                    
                                    const weekDays = ['Th·ª© 2', 'Th·ª© 3', 'Th·ª© 4', 'Th·ª© 5', 'Th·ª© 6', 'Th·ª© 7', 'Ch·ªß nh·∫≠t'];
                                    
                                    return (
                                        <div className="bg-white p-6 rounded-lg shadow-md">
                                            {/* Month navigation */}
                                            <div className="flex items-center justify-between mb-6">
                                                <button
                                                    onClick={() => {
                                                        const prevMonth = new Date(currentMonth);
                                                        prevMonth.setMonth(prevMonth.getMonth() - 1);
                                                        setCurrentMonth(prevMonth);
                                                    }}
                                                    className="px-4 py-2 text-sm font-semibold bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200"
                                                >
                                                    ‚Äπ Th√°ng tr∆∞·ªõc
                                                </button>
                                                <h2 className="text-xl font-bold text-gray-800">
                                                    {currentMonth.toLocaleDateString('vi-VN', { month: 'long', year: 'numeric' })}
                                                </h2>
                                                <button
                                                    onClick={() => {
                                                        const nextMonth = new Date(currentMonth);
                                                        nextMonth.setMonth(nextMonth.getMonth() + 1);
                                                        setCurrentMonth(nextMonth);
                                                    }}
                                                    className="px-4 py-2 text-sm font-semibold bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200"
                                                >
                                                    Th√°ng sau ‚Ä∫
                                                </button>
                                            </div>
                                            
                                            {/* Calendar grid */}
                                            <div className="grid grid-cols-7 gap-2">
                                                {/* Week day headers */}
                                                {weekDays.map(day => (
                                                    <div key={day} className="p-2 text-center font-semibold text-gray-700 bg-gray-50 rounded">
                                                        {day}
                                                    </div>
                                                ))}
                                                
                                                {/* Calendar days */}
                                                {days.map((date, index) => {
                                                    if (!date) {
                                                        return <div key={`empty-${index}`} className="p-2 min-h-[100px] border border-gray-200 rounded bg-gray-50"></div>;
                                                    }
                                                    
                                                    // Format date as YYYY-MM-DD using local date (not UTC)
                                                    const year = date.getFullYear();
                                                    const month = String(date.getMonth() + 1).padStart(2, '0');
                                                    const day = String(date.getDate()).padStart(2, '0');
                                                    const dateKey = `${year}-${month}-${day}`;
                                                    const dayAppointments = appointmentsByDate.get(dateKey) || [];
                                                    const isToday = date.toDateString() === new Date().toDateString();
                                                    
                                                    return (
                                                        <div
                                                            key={dateKey}
                                                            className={`p-2 min-h-[100px] border rounded ${isToday ? 'border-brand-primary bg-brand-secondary' : 'border-gray-200 bg-white'} hover:bg-gray-50 transition-colors`}
                                                        >
                                                            <div className={`text-sm font-semibold mb-1 ${isToday ? 'text-brand-primary' : 'text-gray-800'}`}>
                                                                {date.getDate()}
                                                            </div>
                                                            <div className="space-y-1">
                                                                {dayAppointments.map(app => {
                                                                    const getStatusColor = () => {
                                                                        if (app.status === 'pending') return 'bg-yellow-100 text-yellow-800';
                                                                        if (app.status === 'upcoming') return 'bg-blue-100 text-blue-800';
                                                                        if (app.status === 'in-progress') return 'bg-purple-100 text-purple-800';
                                                                        return 'bg-gray-100 text-gray-800';
                                                                    };
                                                                    
                                                                    return (
                                                                        <div
                                                                            key={app.id}
                                                                            onClick={() => setViewingAppointment(app)}
                                                                            className={`text-xs p-1.5 rounded cursor-pointer transition-shadow hover:shadow-md ${getStatusColor()}`}
                                                                            title={`${app.time} - ${app.serviceName}`}
                                                                        >
                                                                            <div className="font-semibold truncate">{app.time}</div>
                                                                            <div className="truncate font-medium">{app.serviceName}</div>
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    );
                                })()
                            ) : (
                                <p className="text-center text-gray-500 py-10">Kh√¥ng c√≥ l·ªãch h·∫πn s·∫Øp t·ªõi.</p>
                            )}
                        </div>
                    )}
                    
                    {activeTab === 'history' && (
                         <div className="space-y-6">
                            <div className="bg-white p-4 rounded-lg shadow-md grid grid-cols-1 md:grid-cols-4 gap-4 items-center">
                                <select value={historySort} onChange={e => setHistorySort(e.target.value)} className="w-full p-2 border rounded-md bg-white">
                                    <option value="date-desc">S·∫Øp x·∫øp theo: Ng√†y h·∫πn (M·ªõi nh·∫•t)</option>
                                    <option value="date-asc">S·∫Øp x·∫øp theo: Ng√†y h·∫πn (C≈© nh·∫•t)</option>
                                </select>
                                <select value={historyFilterService} onChange={e => setHistoryFilterService(e.target.value)} className="w-full p-2 border rounded-md bg-white">
                                    <option value="all">T·∫•t c·∫£ d·ªãch v·ª•</option>
                                    {serviceFilterOptions.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}
                                </select>
                                 <div className="flex items-center justify-center gap-2">
                                    {['all', 'completed', 'cancelled'].map(filter => {
                                        const labels: Record<string, string> = {all: 'T·∫•t c·∫£', completed: 'Ho√†n th√†nh', cancelled: 'ƒê√£ h·ªßy'};
                                        return <button key={filter} onClick={() => setHistoryFilterStatus(filter)} className={`px-3 py-1.5 text-sm font-semibold rounded-full ${historyFilterStatus === filter ? 'bg-brand-primary text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>{labels[filter]}</button>
                                    })}
                                </div>
                                <div className="flex items-center justify-center gap-2">
                                    {['all', 'today', 'this-week', 'this-month'].map(filter => {
                                        const labels: Record<string, string> = {all: 'T·∫•t c·∫£', today: 'H√¥m nay', 'this-week': 'Tu·∫ßn n√†y', 'this-month': 'Th√°ng n√†y'};
                                        return <button key={filter} onClick={() => setHistoryFilterTime(filter)} className={`px-3 py-1.5 text-sm font-semibold rounded-full ${historyFilterTime === filter ? 'bg-brand-primary text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>{labels[filter]}</button>
                                    })}
                                </div>
                            </div>

                            {displayHistory.length > 0 ? (
                                displayHistory.map(app => <HistoryAppointmentCard key={app.id} appointment={app} />)
                            ) : (
                                <p className="text-center text-gray-500 py-10">Kh√¥ng c√≥ l·ªãch s·ª≠ h·∫πn n√†o.</p>
                            )}
                        </div>
                    )}
                    
                    {activeTab === 'courses' && (
                        <div className="space-y-6">
                            {/* Status Tabs */}
                            <div className="bg-white p-4 rounded-lg shadow-md flex items-center justify-center gap-2 border-b-2 border-gray-200">
                                <button 
                                    onClick={() => setCoursesFilterStatus('active')} 
                                    className={`px-6 py-3 text-base font-semibold rounded-lg transition-colors ${
                                        coursesFilterStatus === 'active' 
                                            ? 'bg-brand-primary text-white border-2 border-brand-primary' 
                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200 border-2 border-transparent'
                                    }`}
                                >
                                    Li·ªáu tr√¨nh ƒëang th·ª±c hi·ªán
                                </button>
                                <button 
                                    onClick={() => setCoursesFilterStatus('completed')} 
                                    className={`px-6 py-3 text-base font-semibold rounded-lg transition-colors ${
                                        coursesFilterStatus === 'completed' 
                                            ? 'bg-brand-primary text-white border-2 border-brand-primary' 
                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200 border-2 border-transparent'
                                    }`}
                                >
                                    Li·ªáu tr√¨nh ƒë√£ xong
                                </button>
                            </div>
                            
                            {displayCourses.length > 0 ? (
                                displayCourses.map(course => <TreatmentCourseCard key={course.id} course={course} />)
                            ) : (
                                <div className="text-center py-10 bg-white rounded-lg shadow-md">
                                    <p className="text-lg text-gray-500">
                                        {coursesFilterStatus === 'active' 
                                            ? 'B·∫°n ch∆∞a c√≥ li·ªáu tr√¨nh ƒëang th·ª±c hi·ªán n√†o.' 
                                            : 'B·∫°n ch∆∞a c√≥ li·ªáu tr√¨nh ƒë√£ ho√†n th√†nh n√†o.'}
                                    </p>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            </div>

            {viewingAppointment && (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={() => setViewingAppointment(null)}>
                    <div className="bg-white p-8 rounded-lg shadow-xl max-w-lg w-full transform transition-all animate-fadeIn" onClick={(e) => e.stopPropagation()}>
                        <div className="flex justify-between items-start mb-4">
                            <h2 className="text-2xl font-serif font-bold text-brand-dark">Chi Ti·∫øt L·ªãch H·∫πn</h2>
                            <button onClick={() => setViewingAppointment(null)} className="text-gray-400 hover:text-gray-800 text-3xl font-light leading-none">&times;</button>
                        </div>
                        <div className="space-y-5 text-sm sm:text-base">
                            <div className="pb-3 border-b">
                                <p className="text-sm text-gray-500">D·ªãch v·ª•</p>
                                <p className="text-lg font-bold text-brand-primary">{viewingAppointment.serviceName}</p>
                            </div>
                            <div className="grid grid-cols-2 gap-4 pb-3 border-b">
                                <div>
                                    <p className="text-sm text-gray-500">Ng√†y h·∫πn</p>
                                    <p className="font-semibold text-gray-800">{viewingAppointment.dateTime.toLocaleDateString('vi-VN')}</p>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-500">Gi·ªù h·∫πn</p>
                                    <p className="font-semibold text-gray-800">{viewingAppointment.time}</p>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-500">Th·ªùi l∆∞·ª£ng</p>
                                    <p className="font-semibold text-gray-800">{allServices.find(s => s.id === viewingAppointment.serviceId)?.duration} ph√∫t</p>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-500">K·ªπ thu·∫≠t vi√™n</p>
                                    <p className="font-semibold text-gray-800">{viewingAppointment.Therapist?.name || (allUsers.find(u => u.id === viewingAppointment.therapistId)?.name) || 'Ch∆∞a ph√¢n c√¥ng'}</p>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-500">Tr·∫°ng th√°i thanh to√°n</p>
                                    <span className={`px-2 py-1 text-xs font-semibold rounded-full ${
                                        viewingAppointment.status === 'cancelled'
                                            ? 'bg-gray-100 text-gray-600'
                                            : viewingAppointment.status === 'completed'
                                                ? 'bg-green-100 text-green-800'
                                                : viewingAppointment.paymentStatus === 'Paid'
                                                    ? 'bg-green-100 text-green-800'
                                                    : 'bg-yellow-100 text-yellow-800'
                                    }`}>
                                        {viewingAppointment.status === 'cancelled'
                                            ? 'Ch∆∞a thanh to√°n'
                                            : viewingAppointment.status === 'completed'
                                                ? 'ƒê√£ thanh to√°n'
                                                : viewingAppointment.paymentStatus === 'Paid'
                                                    ? 'ƒê√£ thanh to√°n'
                                                    : 'Ch∆∞a thanh to√°n'}
                                    </span>
                                </div>
                            </div>
                            {viewingAppointment.notesForTherapist && (
                                <div>
                                    <p className="text-sm text-gray-500">Ghi ch√∫ c·ªßa b·∫°n</p>
                                    <p className="font-semibold text-gray-800 italic bg-gray-50 p-2 rounded-md">"{viewingAppointment.notesForTherapist}"</p>
                                </div>
                            )}
                        </div>
                        <div className="mt-6 text-right">
                            <button onClick={() => setViewingAppointment(null)} className="bg-gray-200 text-gray-800 font-bold py-2 px-6 rounded-lg hover:bg-gray-300 transition-colors duration-300">ƒê√≥ng</button>
                        </div>
                    </div>
                </div>
            )}
            
            {appointmentToCancel && (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={() => setAppointmentToCancel(null)}>
                    <div className="bg-white p-8 rounded-lg shadow-xl max-w-md w-full text-center transform transition-all animate-fadeIn" onClick={(e) => e.stopPropagation()}>
                        <div className="mx-auto mb-4 w-16 h-16 bg-red-100 rounded-full flex items-center justify-center">
                            <XCircleIcon className="w-10 h-10 text-red-600" />
                        </div>
                        <h2 className="text-2xl font-bold text-brand-dark mb-4">X√°c nh·∫≠n H·ªßy L·ªãch h·∫πn</h2>
                        <p className="text-md text-brand-text mb-6">
                            B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën h·ªßy l·ªãch h·∫πn cho d·ªãch v·ª• <br/>
                            <strong className="text-brand-primary">{appointmentToCancel.serviceName}</strong> <br/>
                            v√†o l√∫c {appointmentToCancel.time} ng√†y {appointmentToCancel.dateTime.toLocaleDateString('vi-VN')}?
                        </p>
                        <div className="flex justify-center gap-4">
                            <button onClick={() => setAppointmentToCancel(null)} className="bg-gray-200 text-gray-800 font-bold py-2 px-6 rounded-lg hover:bg-gray-300">
                                Kh√¥ng
                            </button>
                            <button onClick={handleCancelAppointment} className="bg-red-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-red-700">
                                X√°c nh·∫≠n H·ªßy
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};